# GitHub Actions Workflow: Production CI/CD for Full-Stack Application
#
# This workflow automates the linting, testing, building, and deployment of a
# full-stack application (React Frontend, Node.js Backend) to a production-like
# environment. It follows senior-level DevOps practices, including:
# - Modular jobs for clarity and parallelism.
# - Caching for dependency management to speed up builds.
# - Security scanning (npm audit).
# - Containerization with Docker and deployment to GitHub Container Registry (GHCR).
# - Database migration as a separate, controlled step.
# - Secret management for all sensitive variables.
# - Conditional execution and failure notifications.

name: Production CI/CD Pipeline

# Trigger conditions:
# 1. On any push to the 'main' branch.
# 2. When a new release is created via the GitHub UI.
on:
  push:
    branches: [ "main" ]
  release:
    types: [ "created" ]

# Environment variables available to all jobs.
env:
  REGISTRY: ghcr.io
  # Generates a lowercase image name from the repository owner and name.
  # e.g., "my-org/my-cool-repo"
  IMAGE_NAME: ${{ lower.github.repository }}


jobs:
  # =================================================================
  # LINT JOB: Checks for code quality and style issues.
  # =================================================================
  lint:
    name: "Code Quality: Lint"
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          # Use cache for the package manager to speed up subsequent runs.
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json
            frontend/package-lock.json

      - name: "Install Backend Dependencies"
        working-directory: ./backend
        # 'npm ci' is used for CI environments. It provides faster, more reliable builds
        # by installing exact versions from package-lock.json.
        run: npm ci

      - name: "Run Backend Linter"
        working-directory: ./backend
        # Assumes a "lint" script is defined in backend/package.json
        run: npm run lint

      - name: "Install Frontend Dependencies"
        working-directory: ./frontend
        run: npm ci

      - name: "Run Frontend Linter"
        working-directory: ./frontend
        # Assumes a "lint" script is defined in frontend/package.json
        run: npm run lint

  # =================================================================
  # TEST JOB: Runs automated tests and security audits.
  # =================================================================
  test:
    name: "Code Quality: Test & Scan"
    runs-on: ubuntu-latest
    # This job will only run after the 'lint' job has succeeded.
    needs: lint
    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json
            frontend/package-lock.json

      - name: "Install Backend Dependencies & Run Security Audit"
        working-directory: ./backend
        run: |
          npm ci
          # Fails the build if vulnerabilities of high severity or greater are found.
          npm audit --audit-level=high

      - name: "Run Backend Tests"
        working-directory: ./backend
        run: npm test
        # Provide necessary environment variables for testing from GitHub Secrets.
        env:
          JWT_SECRET: ${{ secrets.TEST_JWT_SECRET }}
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

      - name: "Install Frontend Dependencies & Run Security Audit"
        working-directory: ./frontend
        run: |
          npm ci
          npm audit --audit-level=high

      - name: "Run Frontend Tests"
        working-directory: ./frontend
        run: npm test

  # =================================================================
  # BUILD & PUSH DOCKER IMAGES JOB
  # =================================================================
  build_and_push_docker:
    name: "Build & Push Docker Images"
    runs-on: ubuntu-latest
    needs: test
    # Set permissions for the job to allow writing to GitHub Packages (Container Registry).
    permissions:
      contents: read
      packages: write

    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Log in to GitHub Container Registry"
        # This action uses a GITHUB_TOKEN to authenticate with GHCR.
        # The token has the necessary scopes due to the 'permissions' block above.
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: "Extract Docker metadata"
        # This action generates tags for the Docker images based on git history.
        # e.g., 'latest', 'sha-<short-sha>', 'v1.2.3' (for git tags).
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: "Build and push Backend Docker image"
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest, ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: "Build and push Frontend Docker image"
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest, ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}
          # Pass build arguments to the Dockerfile if needed.
          # For example, to expose the backend API URL to the React app at build time.
          build-args: |
            VITE_API_BASE_URL=${{ vars.PROD_API_BASE_URL || 'https://api.yourdomain.com' }}

  # =================================================================
  # RUN DATABASE MIGRATIONS JOB
  # =================================================================
  run_migrations:
    name: "Sync Database Schema"
    runs-on: ubuntu-latest
    needs: build_and_push_docker
    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: "Install Backend Dependencies"
        working-directory: ./backend
        run: npm ci

      - name: "Run Database Migrations"
        working-directory: ./backend
        # This command connects to the production database and applies pending migrations.
        # It's critical that the database is accessible from the GitHub Actions runner.
        # Ensure your network rules/firewalls allow this connection.
        # Assumes a 'db:migrate' script in backend/package.json, e.g., "prisma migrate deploy"
        run: npm run db:migrate
        env:
          # The production database URL must be stored as a secret.
          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}

  # =================================================================
  # DEPLOY JOB: Deploys the application to the target infrastructure.
  # =================================================================
  deploy:
    name: "Deploy to Production"
    runs-on: ubuntu-latest
    needs: run_migrations
    environment:
      name: production
      url: https://yourdomain.com # <-- UPDATE this with your production URL

    steps:
      - name: "Deploy to Target Environment (Example: SSH)"
        # This is a placeholder for your deployment strategy.
        # The following example shows how to SSH into a server to run deployment commands.
        # This is suitable for targets like EC2, DigitalOcean Droplets, or any dedicated server.
        #
        # For serverless or container orchestration platforms (like Render, AWS ECS, Kubernetes),
        # you would replace this step with a provider-specific action or CLI command.
        #
        # EXAMPLE: Using SSH to pull new images and restart a Docker Compose setup.
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_KEY }}
          script: |
            # Navigate to the project directory on the server
            cd /path/to/your/project/myshop

            # Log in to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull the latest images pushed in the 'build_and_push_docker' job
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest

            # Set environment variables for docker-compose from GitHub Secrets
            # This exports them for the 'docker-compose up' command.
            export DATABASE_URL="${{ secrets.PROD_DATABASE_URL }}"
            export JWT_SECRET="${{ secrets.PROD_JWT_SECRET }}"
            export CORS_ORIGIN="${{ vars.PROD_CORS_ORIGIN || 'https://yourdomain.com' }}"

            # Bring down the old containers and start the new ones.
            # The '--remove-orphans' flag cleans up any old, unused containers.
            docker-compose up -d --remove-orphans

            # Clean up dangling Docker images to save disk space
            docker image prune -f

  # =================================================================
  # NOTIFY FAILURE JOB: Sends a notification if any job fails.
  # =================================================================
  notify_on_failure:
    name: "Notify on Failure"
    runs-on: ubuntu-latest
    # This job runs ONLY if any of the previous jobs in the matrix have failed.
    if: failure()
    # It needs all other jobs to be completed (successfully or not) to make a final decision.
    needs: [lint, test, build_and_push_docker, run_migrations, deploy]
    steps:
      - name: "Send Slack Notification"
        # This is a placeholder for a notification step.
        # The 'slackapi/slack-github-action' is a popular choice.
        uses: slackapi/slack-github-action@v1.26.0
        with:
          # The payload can be customized to include details about the failure.
          payload: |
            {
              "text": "ðŸš¨ Production pipeline FAILED for `${{ github.repository }}`.",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸš¨ Production pipeline FAILED for `${{ github.repository }}`."
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    { "type": "mrkdwn", "text": "*Branch:*\n`${{ github.ref_name }}`" },
                    { "type": "mrkdwn", "text": "*Commit:*\n`${{ github.sha }}`" },
                    { "type": "mrkdwn", "text": "*Triggered by:*\n`${{ github.actor }}`" }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": { "type": "plain_text", "text": "View Workflow Run" },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          # The webhook URL for your Slack channel must be stored as a secret.
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
